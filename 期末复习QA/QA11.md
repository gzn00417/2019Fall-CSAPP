# Q&A11

---
## 静态局部变量是怎么生成汇编语言的？
空间：全局区
赋初值：定义该变量的函数第一次被调用时
生命周期：整个源程序的周期

---
## 分析全局变量、局部变量、传值的参数的生命周期
静态全局变量：整个源程序的周期
动态全局变量：整个源程序的周期
静态局部变量：整个源程序的周期
动态局部变量：定义它的函数的周期
传值的参数：定义它的函数的周期

---
## 简述缓冲器溢出的原理
缓冲区溢出，简单的说就是计算机对接收的输入数据没有进行有效的检测，向缓冲区内填充数据时超过了缓冲区本身的容量，而导致数据溢出到被分配空间之外的内存空间，使得溢出的数据覆盖了其他内存空间的数据。

---
## 怎么攻击缓冲器溢出的漏洞？
攻击原理（3个采分点）：向程序输入缓冲区写入特定的数据，例如在gets读入字符串时，使位于栈中的缓冲区数据溢出，用特定的内容覆盖栈中的内容，例如函数返回地址等，使得程序在读入字符串，结束函数gets从栈中读取返回地址时，错误地返回到特定的位置，执行特定的代码，达到攻击的目的。

---
## 怎么防范缓冲器溢出漏洞？
防范方法(2个采分点,有2个就算对)：
1. 代码中避免溢出漏洞：例如使用限制字符串长度的库函数
2. 随机栈偏移：程序启动后，在栈中分配随机数量的空间，将移动整个程序使用的栈空间地址
3. 限制可执行代码的区域
4. 进行栈破坏检查——金丝雀

---
## 结构体的成员在汇编语言层面是怎么操作的？
结构体用内存块来表示
足够大，可容纳所有字段
字段顺序必须与声明一致
即便其他顺序能使得内存更紧凑——也不行！
编译器决定总的尺寸和各字段位置
机器级程序不解读(理解)源代码中的结构体
数组元素的地址
每个结构体成员的偏移量(Offset)是在编译阶段确定的
地址计算形式:r + size*idx
结构体成员通过结构体基地址+偏移量的方式访问

---
#结构体成员作为参数传输是怎么实现的？
传递结构体基地址+偏移量处的对应成员

---
#结构体成员作为返回值是怎么实现的？
返回结构体基地址+偏移量处的对应成员


