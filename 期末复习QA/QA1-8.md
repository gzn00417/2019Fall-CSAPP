# QA1
## 1.简述C、ASM、ML的关系，各自优缺点？ ##
机器语言是二进制数据表示的语言，机器可以直接识别；汇编语言是与机器指令一一对应的助记符,是一种低级语言,经过汇编和链接之后机器可以运行；C语言在低级语言的基础上，采用最接近人类自然语言的单词和符号来表示一组低级语言程序。

**C语言的优点**：提供了结构化程序设计的环境和工具，设计出来的程序可读性好，可维护性强，可靠性高；抽象程度高，远离机器语言，和计算机硬件关系不大，编程门槛低，无需懂计算机原理和计算机结构；编写出来的程序可移植性好，重用率高
缺点：相对汇编语言和机器语言来说执行效率不高

**汇编语言的优点：**能发挥计算机的特定和功能，程序紧凑，资源利用率高
缺点：代码可读性较差，难以维护；特定的汇编语言和特定的机器语言指令集一一对应，只能针对特定体系结构和处理器进行优化,可移植性差；开发效率低,时间长且单调；编程门槛高，需要了解计算机原理和计算机结构

**机器语言优点:**能利用机器指令精准的描述算法,编程质量高；所占用储存空间小；执行速度快
缺点:开发过程细节繁琐，编程门槛高；可读性差,不便于交流；严重依赖具体的计算机,可移植性差,重用性差。


##2.Hello.c 经过那些工具、步骤、生成什么类型的文件？ ##
 ![](https://imgsa.baidu.com/forum/w%3D580/sign=e04ea1d4db3f8794d3ff4826e21b0ead/9ee6fe87e950352ab45767645c43fbf2b2118bba.jpg)

##3. 什么是程序可移植性？汇编语言可移植吗？为什么？ 
程序可移植性指在不同环境下，其是够具备可以被重复使用的性质。在移植到不同的系统平台使，所做的改动少，则可移植性好；否则，可移植性差。


**汇编语言可移植性差。**

原因：汇编语言是机器语言的主机语言，针对特定的指令系统，和特定的机器指令集一一对应；程序结构性差，不便于模块化的设计，也造成可移植性差

## 4.	编译与解释有什么区别？各举出2个语言的例子 
编译程序是将高级语言程序转换为机器级目标程序，执行时只需要启动目标程序即可，如将C、C++编译为Windows上的可执行2进制文件。
## 5.	解释是将高级语言语句逐条翻译成机器指令并立即执行，不生成目标 文件，例如Java需要目标机器上安装JRE。
## 6.	程序优化的目的？ ##
1.	提高程序运行效率（性能）
2.	使程序更加节省存储空间和运行空间
3.	程序更加正确
4.	更可靠
5.	可移植性更好
6.	功能更强大
7.	使用更方便
8.	格式符合编程规范，接口规范
9.	更易懂（能读明白，有注释，模块化）
10.	更美

7.	计算机软件与硬件的界面/接口是什么？
操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：
1. 文件是对I/O设备的抽象
2. 虚拟内存是对主存和磁盘的抽象
3. 进程是处理器、主存和I/O设备的抽象

## 8.	简述中间层语言及其运行机制 （这个应该不会考吧，没找到答案，下面这段随便看看吧）
因为很多程序只能在一种操作系统上运行。在其他操作系统上不能运行。那怎么能够支持多重硬件平台、多种软件平台（包括操作系统）呢？

这就要用到一种新的技术——中间层语言，微软有自己的中间层语言，Java也有（叫Java字节码），凡是微软的语言比如C、C++，在运行时都要先编译成MSIL（中间层语言)，然后通过微软的通用语言运行时（Common Language Runtime）来运行，而Java语言在编译成Java字节码之后要在Java虚拟机上运行，Java虚拟机通过通用语言运行时对生成的中间层代码进行解释。这样程序的可移植性就有了提高。因此我们一般编程只需面对中间层预言、虚拟机即可，这是计算机系统抽象表示的发展趋势

在编译器将源代码编译为目的码的过程中，会先将源代码转换为一个或多个的中间表述，以方便编译器进行最佳化，并产生出目的机器的机器语言。通常，中间语言的设计与一般的机器语言有三个不同之处：

每个指令代表仅有一个基本的操作。举例来说，在微处理器中出现的shift-add定址模式在中间语言不会出现。

指令集内可能不会包含控制流程的资讯。

暂存器可用的数量可能会很大，甚至没有限制。

最常见的中间语言表述形式，是三位址码（Three address code）。

这个术语也同时用来代称一些作为中间层的语言，有些高级语言不会输出为机器语言，它们仅会输出这种中间语言，而这些中间语言则会像一般语言一样，提交给编译器，编译为机器语言。这通常被用于让最佳化的过程更简单，也用于增进可移植性的能力，改进移植的方式则是利用中间语言的编译器，可以编译出许多中央处理器及操作系统可使用的机器码，例如C语言。中间语言的复杂度，通常介于高阶语言及低级语言之间，例如汇编语言。

## 9.	设计开发一个Java处理器是否可行？ ##
查不到
https://blog.csdn.net/zxadcsdn/article/details/86409600
这篇博客画了一个java处理器的图


## 11.	程序执行结果与那些相关呢？程序编写、语言处理系统、OS、ISA-机器语言、微体系结构等 ##
程序执行结果不仅取决于算法、程序编写，而且取决于语言处理系统、操作系统、ISA、微体系结构。
# QA2 #
## 1.8086 CPU内部寄存器组有哪几个？都是多少位的 ##？
 ![](https://imgsa.baidu.com/forum/w%3D580/sign=c8cb904d9fef76c6d0d2fb23ad16fdf6/3a3ac30828381f30c432cfc5a6014c086e06f04d.jpg)
都是16位
汇编语言中寄存器功能的解释：
https://blog.csdn.net/a675311/article/details/53220590

## 2.8086 访问存储器的地址有哪部分组成？物理地址怎么形成的？ ##

逻辑地址由段地址和段内偏移地址两部分组成。

存储单元的物理地址由地址加法器生成。寻址时，CPU首先将段地址和段内偏移地址送入地址加法器，地址加法器将段地址向左偏移四位并且与段内偏移地址相加，得到一个20位的物理地址。

## 3.BIU与EU是怎么完成指令执行的？ ##
BIU指总线接口单元，EU指执行单元。

当指令队列中有2个空字节时，BIU自动把指令取到指令队列中，当指令队列已满，而EU无总线访问请求时，BIU进入空闲状态。

EU从指令队列的头部取出指令，并执行该指令。在执行中，如果需要访问内存或者I/O设备，则EU请求BIU取操作数，并直到需要的操作数到来后，EU才继续操作。若BIU处于空闲态，它立即响应请求，若BIU正在取指令到指令队列，它先完成取指令操作，再响应EU的请求。

EU在执行转移、调用，返回等指令时，指令队列中的指令被清除，BIU重新从存储器中取出指令送到指令队列，EU才继续执行指令。

## 4. int x ;    AX=100； AX=AX+256；   x=AX；
程序/指令中的常数在内存哪个区域/段？ ##
看不懂题目
未初始化的静态变量和初始化为0的静态变量或者全局变量在.bss区
已初始化的静态变量和全局变量在.data区
局部变量在栈里

## 5.全局变量x以一种什么方式在机器/汇编程序中出现？怎么访问的？至少访几次存储器 ##？
采用内存引用的方式访问全局变量。
## 
## 6.C语言的数据类型char、short int、int、long、long long、float、double、long double、指针等在32/64位系统中占多少个字节？邮编为什么char[]? ## ##
 ![](https://imgsa.baidu.com/forum/w%3D580/sign=b836fddeb6014a90813e46b599773971/0b4437deb48f8c5432cf874335292df5e0fe7f50.jpg)

（实验报告里面扒下来的）

# QA3 #
## 0. 计算机是64位的是指CPU寄存器是64位的？ ##
计算机是xx位的，指的是计算机CPU字的长度（字长）。
计算机中ALU的位数 = CPU中通用寄存器的位数 = 计算机的位数

## 1.	常量表达式是谁来计算的？  ##
编译器在编译阶段计算。
   
## 2.0与‘0'谁大?差多少?空间呢?? ##
字符‘0’的ASCII码是48，则‘0’比0大，差48。

空间和声明的类型有关，如果0声明为int, ‘0’声明为char,则数字0占用的空间较大。
 
## 2.	C源程序中的有符号常数，是怎么变成二进制补码的和进行运算的？ 
什么破问题。

## 3.	strlen(“1234567	我想毕业\n”)=？怎么算汉字数 ##  
strlen计算的长度是该字符串对应的编码占用的字节数，所以这个长度在不同的编码下结果也不相同。例如，gbk编码下中文字符占用2字节，UTF-8存储中文时占2～4个字节.
计算汉字数？在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围一般是在0080-07FF之间，因此是2个字节表示。计算长度时可以根据
1字节 0xxxxxxx 
2字节 110xxxxx 10xxxxxx 
3字节 1110xxxx 10xxxxxx 10xxxxxx 
4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 
5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 
6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 
由开始的0和1的个数来判断字节数，从而计算。（我自己这么觉得，查不到一个靠谱的答案）
[https://blog.csdn.net/u014431852/article/details/48003321](https://blog.csdn.net/u014431852/article/details/48003321)
    [https://blog.csdn.net/tinyletero/article/details/8201465](https://blog.csdn.net/tinyletero/article/details/8201465)
## 5.汉字是怎么输入进入源程序的（Win/Linux）？ ##
## 6. OS内核的编码决定了基于其上的系统软件与应用软件的编码要与其一致。不一致怎么办?要转换吗?谁来转换? ##
要转换。
## 7.当前的源程序编码是什么? 可以变吗?  ##

[https://wenku.baidu.com/view/191f12537cd184254b353560.html](https://wenku.baidu.com/view/191f12537cd184254b353560.html)这个讲的很清楚
## 8.	汉字是怎么显示/打印输出的？ ##
ASCII码->编号->字库中点阵图编码->打印

# QA4
## 1. IEEE754比整数部分10位+小数部分20位的表示方法有什么优点？  缺点呢—考虑下? ##
优点：可表示数值范围较大，精度较高；不知道有啥缺点，等我问问老师
## 2. float非无穷的最大值，最小值？ ##
float非无穷的最大值IEEE754表示是0111_1111_0111_1111_1111_1111_1111_1111
阶码是127，尾数是2-2^（-23）。所以最大值是（2-2^（-23））* 2^127
最小值符号位取1即可
正数的最小值，IEEE754表示是0000_0000_0000_0000_0000_0000_0000_0001
阶码是1-127 = -126，尾数是2^（-23）。值是2^（-149）
## 3. Float的最大绝对值？最小绝对值？ ##
和上面重复
## 4. float数 1，65536，0.4，-1，0的内存表示 ##
1 = 1*2^0 则frac = 000_0000_0000_0000_0000_0000, exp = 0111_1111(127)
表示是0011_1111_1000_0000_0000_0000_0000_0000
65536 = 2^16, 则frac = 000_0000_0000_0000_0000_0000,exp = 1000_1111
表示是0100_0111_1000_0000_0000_0000_0000_0000

0.4 = 0.0110_0110_0110……，涉及到舍入问题，frac = 100_1100_1100_1100_1100_1100
exp = 0111_1101(125),表示是0011_1111_0101_1011_0110_1101_1011_0111
-1和0略
## 5. 一个数的Float形式是唯一的吗？（除了0） ##
是，根据IEEE754标准，一个数字对应的格式是唯一的
## 6. 每一个IEEE754编码对应的数是唯一的吗？ ##
不是，有些数字不能用二进制数字精确表示，涉及到舍入问题，可能不同的数字舍入之后对应的IEEE754编码完全相同。另外，当数字超出IEEE编码所能表示的范围，不同数字对应的编码都是一样的。（原因是我自己的想法）
## 7. Float的阶码范围是多少？ ##
-126 ~ +127
简述Float数据的浮点数密度分布？
分布不均匀，靠近远点处它们更稠密（课本P80）
## 8. C语言中除以0一定报错溢出吗？ ##
整数报错，浮点无穷大X/0>Y  可以
## 9. int与float都占32个二进制位，Float与INT相比谁的个数多？各自是多少个？多多少？  （+-0、nan） ##
Int表示的个数多（不知道这个表示是什么意思，我理解为精确表示）

Int 可以表示2^32个数字（+0和-0看做不同的数）

float可以表示2^32-2^24个数字（+0.0和-0.0看做不同的数，不算INF和NAN）

## 10. Float的最大密度区间（非无穷）？Float数多少？密度多少？ ##
按照阶码区域写出float的最大密度区域的范围及其密度，最小密度区域及其密度（区域长度/表示的浮点个数）

阶码是0000_0000(表示的数值范围是-1.1754942E-38 到1.1754942E-38）、(1 - (1/2)^23)*2^-149_（最小密度区间）、阶码是1111_1110(表示的数值范围是-3.4028235E38到-1.7014118E38和1.7014118E38到3.4028235E38）、
（2^104 - 2^81）（最大密度区间）


 微观世界：能够区别最小的变化___2^-149_____，其10进制科学记数法为_____1.4E-45____

宏观世界：不能区别最大的变化____2^128____，其10进制科学记数法为______3.4*10^38___

## 11. Float的最小密度区间？Float数多少？密度多少？ ##
同上
## 12. Float最大密度区间是最小密度区间的密度的多少倍？ ##
约等于2^253 - 2^230
## 13. float最大的负数是多少==最小的正数是多少？ ##
正数的最小值，IEEE754表示是0000_0000_0000_0000_0000_0000_0000_0001
阶码是1-127 = -126，尾数是2^（-23）。值是2^（-149）

## 14. 怎么判断和定义浮点数的无穷大以及NaN？ ##
当exp部分都是1

如果frac部分的位模式都是1表示INF

否则，表示NAN

浮点数的表示，越小精度越高，越大精度越低，这也基本符合数据处理的规律。太大的数据差点没啥，就是个规模而已。如人口、GDP等，没有必要到个、圆角分。
## 15. Float使用注意事项？  怎么比较两个float数据？ ##
先判断是不是NAN，如果有一个数字是NAN，比较无意义。

如果均是数字，则按照下面原则进行比较：

先比较符号位，符号位是0的比符号位是1的大
。
阶码从最高位进行比较，例如阶码第一位是1的数字比阶码第一位是0的数字大，如果第一位相同向后比较即可，遵从同样的规则，直到分区处大小或者阶码相同。

如果阶码相同则比较尾数部分，同样是先比较高位之后比较低位即可。

## 16. 浮点数的舍入采用什么规则？ ##
IEEE浮点格式定义了四种不同方式的舍入方法，默认的方式是找到最接近的匹配，而其他三种可用于计算上界和下界。向偶数舍入是默认的舍入方法。
## 17. 向偶数舍入方法，尾数会不会产生溢出，如果产生溢出怎么办？阶码会不会溢出？怎么办？printf函数把浮点数按照十进制数打印%10.2f，按照什么舍入原则呢？  到底是什么？不要想当然 ##
向偶数舍入，尾数可能产生溢出。

产生溢出，把阶码加一即可。

阶码产生溢出，说明这个数字超出了浮点数可以表示的范围。

按照十进制数字的四舍五入原则。
## 18. 通用寄存器的通用是什么意思 ##
因为通用寄存器既可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。
## 19. 32位CPU怎么实现64位加法 ##
大多数处理器都包含一个进位位和溢出位来支持位宽大于机器字长的数字的运算。
进位位用于无符号运算，溢出位用于有符号数运算。并且，位宽较大的数字分开存储即可。（参考家庭作业2.75）

大多数操作基本上是串行的。当在二进制电平上进行加法运算时，您需要两个输入位，并产生一个结果位和一个进位位。然后当将下一个最低有效位加入时，进位位用作输入，以此类推（

CPU字长只是限制了它可以运行的最大时钟速度

原文链接http://www.it1352.com/489105.html

## (*)20. 数组、结构、指针各用什么寄存器指示？ ##


## 21. 标志寄存器有什么作用？ ##

（课本）他们描述了最近的算术和逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。

（博客）具有以下 3 种作用。

　　（1）用来存储相关指令的某些执行结果；

　　（2）用来为 CPU 执行相关指令提供行为依据；

　　（3）用来控制 CPU 的相关工作方式

## 21. 状态标志位有哪几个？加法运算会影响那些？ ##
记住四个就行：
CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。


	ZF:零标志。最近的操作得出的结果为0.

	SF:符号标志。最近的操作得到的结果为负数。

	OF:溢出标志。最近的操作导致一个补码溢出一一正溢出或负溢出。

加法运算都可能改变。
详细介绍：
https://www.cnblogs.com/eleven24/articles/7783283.html

## 22.控制标志位 IF/DF作用，怎么改变？（应该不考，毕竟书上没有提到） ##
DF标记块传送是从低地址向高地址传，还是从高地址向低地址传。

IF可以屏蔽 可屏蔽中断请求INTR

如果外设有可屏蔽中断请求INTR，而此时CPU内IF=0，那么CPU不会响应中断

只有可屏蔽中断请求INTR和IF有关系，

内中断和不可屏蔽中断NMI，都不受IF的影响

## 23. CF与OF是什么关系？ ##

CF针对无符号数(将寄存器中的操作数都看作是无符号数)

OF针对有符号数(将寄存器中的操作数都看作是有符号数)

## 24. 计算机怎么判断两个数相加是否超出了范围？ ##

CF位来判断无符号数运算的溢出，OF位来判断补码运算是否溢出。

## 25. 怎么修改IP寄存器？ ##

IP寄存器的值通常不能直接被修改，需要使用call,ret,jmp等控制转移指令类修改。
## 26. 32/64位的cpu中寄存器都是32/64位的？ ##

不是，第三章最后提到的媒体寄存器是256位的，段寄存器（有的说32位，有的说16位）

CPU的字长 == 通用寄存器的位宽

## 27. 请列出C语言的所有操作/指令，与汇编语言对比，说明汇编语言的优点 ##
重点：逻辑操作/位操作

这个不会

## 28. 操作数的寻址方式有哪几种？ ##
![](https://imgsa.baidu.com/forum/w%3D580/sign=c9f0e7b379c6a7efb926a82ecdfbafe9/a31dec381f30e9249678de5d43086e061c95f790.jpg)
##  29. 一/二维数组采用什么寻址方式？ ##
比例变址寻址
## 30.结构体的某一个整型成员采取什么寻址方式？ ##

## 31. 结构体的整形数组采用什么寻址方式？ ##

## 一个C生成的执行程序是多少位的是由谁来决定的？ ##

（A）CPU      （B）OS    （C）编译器   （D）源程序  

** C **

